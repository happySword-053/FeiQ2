1. 什么是「密钥」（Key）？
定义：密钥就是一串乱码（固定长度的二进制数据），只有知道这串乱码的人才能正确把信息「锁」起来或「解锁」。

比喻：把「明文」比作一把未上锁的箱子，密钥就像那把专用的钥匙；你需要同一把钥匙，才能把箱子锁上（加密），也才能再打开它（解密）。

对称加密：这里用的是对称加密（AES-256-CTR），意即加锁和开锁都用同一把钥匙（同一串密钥）。

2. 为什么不能直接用密码当密钥？
用户密码往往长度不一、复杂度不够，有的只有 6–12 个字符；而 AES-256 需要 256 比特（32 字节）长度。

解决方法：把「密码」通过一种叫「密码学派生函数」（PBKDF，Password‑Based Key Derivation Function）的算法，转换成恰好 32 字节的密钥。

在代码里，EVP_BytesToKey 就是做这种「把密码拉伸成密钥」的工作。

3. 什么是「初始化向量」（IV）？
定义：IV（Initialization Vector）也是一串二进制，只会用一次，用来保证同一把钥匙对同一段明文，每次加密结果都不一样。

比喻：同一把钥匙和同一个箱子，如果每次锁时都稍微在锁芯里放一小张随机纸条（IV），就算箱子内容相同，锁上的痕迹也不一样，更难被破解。

代码做法：每次调用 encrypt 时，用 RAND_bytes 随机生成 IV，然后把它拼到密文前面，方便 decrypt 时先取出那串随机纸条。

4. 加密（Encryption）的整体流程
派生密钥

从用户密码（比如 "mysecretpassword"）用 PBKDF 算法生成一个 32 字节的「钥匙」。

生成随机 IV

用真随机数（RAND_bytes）产生 16 字节的「随机纸条」。

真正加密

以「密钥」和「IV」为参数，调用 AES-CTR 模式，把明文数据变成看起来毫无规律的密文数据。

输出格式

把 IV 放到密文前面，一起返回。这样解密时，先把前 16 字节拿去当 IV，剩下的才是密文。

5. 解密（Decryption）的整体流程
取出 IV

从收到的数据前 16 字节，拿到当初加密时随机生成的 IV。

还原密钥

依然用同一个用户密码 + 同样的 PBKDF 算法，生成同一把「钥匙」。

真正解密

用这把「钥匙」和取出的 IV，调用 AES-CTR 模式，把密文「翻转」回原来的明文。

得到明文

流程结束，就能恢复出原来那串字符，比如 Hello World。

6. 为什么要这样做？
保密性：只有知道「密码」的人，才能派生出正确的密钥，也才能解开数据。

抗重放＆防分析：随机 IV 每次都不同，即使明文相同、密码相同，密文也完全不一样，攻击者无法通过比对密文来猜测内容。

性能好：CTR 模式（“计数器模式”）把 AES 变成流密码，速度快，不需要填充（padding），适合大数据量。

具体流程举例
用户密码 → 派生出固定的密钥 K

加密时

随机生成 IV₁（16 字节），调用 AES‑CTR(K, IV₁) 生成伪随机流 S₁

明文 M ⊕ S₁ = 密文 C₁

最终输出的数据就是 IV₁‖C₁

再一次对同样的明文 M，用同样密码

派生出同样的密钥 K

但新生成一个随机 IV₂ ≠ IV₁，调用 AES‑CTR(K, IV₂) 得到伪随机流 S₂

明文 M ⊕ S₂ = 密文 C₂（和 C₁ 完全不同）

输出 IV₂‖C₂

解密时

拿到 IVₓ‖Cₓ（这里 x 可能是 1， 也可能是 2）

从前 16 字节提取出 IVₓ

同样用密码派生出密钥 K

调用 AES‑CTR(K, IVₓ) 重新生成伪随机流 Sₓ

然后 M = Cₓ ⊕ Sₓ

这样，无论加密端生成了哪个随机 IV，只要解密端能获得它，并且用同一把密钥，就能正确还原。